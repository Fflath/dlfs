# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_data.ipynb.

# %% auto 0
__all__ = ['collate_fn', 'inplace', 'collate_dict', 'DataLoaders', 'Sampler', 'BatchSampler', 'accuracy', 'get_dls']

# %% ../nbs/01_data.ipynb 2
import fastcore.all as fc
import random
import torch.multiprocessing as mp

# %% ../nbs/01_data.ipynb 3
import torch
from torch import nn
from torch.utils.data import DataLoader
from torchvision import datasets
from torchvision.transforms import ToTensor
import torchvision.transforms.functional as TF
import torchvision
from torch.utils.data.dataloader import default_collate
from operator import itemgetter


# %% ../nbs/01_data.ipynb 4
def collate_fn(b):
    return {x:torch.stack([TF.to_tensor(o[x]) for o in b]),
            y:tensor([o[y] for o in b])}

# %% ../nbs/01_data.ipynb 5
def inplace(f):
    def _f(b):
        f(b)
        return b
    return _f

# %% ../nbs/01_data.ipynb 7
def collate_dict(ds):
    get = itemgetter(*ds.features)
    def _f(b): return get(default_collate(b))
    return _f
     

# %% ../nbs/01_data.ipynb 8
class DataLoaders:
    def __init__(self, *dls): self.train,self.valid = dls[:2]

    @classmethod
    def from_dd(cls, dd, batch_size, as_tuple=True, **kwargs):
        f = collate_dict(dd['train'])
        return cls(*get_dls(*dd.values(), bs=batch_size, collate_fn=f, **kwargs))
     

# %% ../nbs/01_data.ipynb 9
class Sampler():
    def __init__(self, ds, shuffle=False): self.n,self.shuffle = len(ds),shuffle
    def __iter__(self):
        res = list(range(self.n))
        if self.shuffle: random.shuffle(res)
        return iter(res)

# %% ../nbs/01_data.ipynb 10
class BatchSampler():
    def __init__(self, sampler, bs, drop_last=False): fc.store_attr()
    def __iter__(self): yield from fc.chunked(iter(self.sampler), self.bs, drop_last=self.drop_last)
    def __len__(self): return self.sampler.n//self.bs

# %% ../nbs/01_data.ipynb 11
def accuracy(out, yb): return (out.argmax(dim=1)==yb).float().mean()

# %% ../nbs/01_data.ipynb 12
class DataLoaders:
    def __init__(self, *dls): self.train,self.valid = dls[:2]

    @classmethod
    def from_dd(cls, dd, batch_size, as_tuple=True, **kwargs):
        f = collate_dict(dd['train'])
        return cls(*get_dls(*dd.values(), bs=batch_size, collate_fn=f, **kwargs))

# %% ../nbs/01_data.ipynb 13
def get_dls(train_ds, valid_ds, bs, **kwargs):
    return (DataLoader(train_ds, batch_size=bs, shuffle=True, **kwargs),
            DataLoader(valid_ds, batch_size=bs*2, **kwargs))
